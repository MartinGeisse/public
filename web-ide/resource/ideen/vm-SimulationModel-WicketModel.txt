
SimulationModel und Primary Element werden für zwei Dinge benötigt:
- Simulation
- UI
und werden je Simulation und je Editor einmal erzeugt (-> lightweight).

Entsprechend sind auch die Anforderungen:
- Simulation: korrektes Verhalten, aber nicht Serializable
- UI: Extrem leichtgewichtig, Serializable, kein Verhalten

aber ist schon praktischer, wenn dieselben Kern-Model-Elemente für beides
genommen werden.

Wobei auch der Sim-Teil gerne leichtgewichtig sein darf, und das bedeutet:

-> alle Model-Elemente müssen Serializable sein und sollten lazy loading
   benutzen
-> die UI-Klassen im Ecosim-Sinne müssen UI Input Events verarbeiten und
   dem SimulationModel zur Verfügung stellen. Bei Output Events müssen
   sie diese an die Clients pushen.
-> In SimVM-Editors werden keine UI-Klassen im Ecosim-Sinne verwendet.
   Stattdessen erzeugen die Model Elements bzw. etwas, das diese ausliest,
   Wicket-Komponenten, welche auf das SimulationModel und dessen lazy
   loading zugreift.
-> Die Ecosim-UI-Klassen müssen also nicht serializable sein, weil sie im
   Editor-(Wicket-)Teil gar nicht verwendet werden -- dieses hat ja auch
   kein simuliertes Verhalten, welches das UI ansprechen könnte.

-----

Die Darstellung einer suspendeten VM ist weniger wichtig. Möglichkeiten:
- komplett separates UI. Viele Dinge (Runtime State!) fallen weg, das ist
  ein sehr großer Teil des gesamten UI. Andere Teile kommen dazu, z.B.
  Konfiguration, die nicht an der laufenden VM geändert werden kann.
- Fake Runtime State und die entsprechenden Teile ausblenden
- UI, welches mit beiden Situationen klarkommt.

Grundidee: Kein generell vorgeschriebener weg, sondern VM-Code entscheidet
je Modul selbst.

Das bedeutet aber auch: Die wesentliche Architektur richtet sich danach, wie
*laufende* VMs dargestellt werden. Und für die gilt: Editors haben zwar
keinen eigenen Runtime State, müssen aber den aus der Simulation anzeigen.

Dann wäre zu klären, ob State und Definition getrennt werden. Das würde einiges
komplizierter machen, aber dann müsste nur State vom Sim Thread zum Editor
übermittelt werden. Die wesentliche Komplexität ist aber dann immer noch
im State sichtbar, nämlich Concurrency. Concurrency in der Definition ist
für Architekturfragen vernachlässigbar, eben weil die sich ja gar nicht ändert.

-> Grundgedanke für die Editors einer laufenden VM ist:

	*** Ein Editor für eine laufende VM greift direkt auf das SimulationModel
	aus der Simulation zu. Er hat keine eigenen Daten außer dem ResourceHandle
	für den Anker der VM. ***
	
-> braucht alles nicht Serializable zu sein, da nicht Teil der Wicket-Components,
sondern es wird nur per IModel drauf zugegriffen. Dann verhält es sich auch wie
von Wicket gedacht.

-----

Langsam wird folgendes zum Problem: Verschiedene Editoren öffnen dieselbe SimVM.
Jeder baut sein eigenes SimulationModel. Bei der eigentlichen Simulation gibt
es aber ein gemeinsames SimModel in der Simulation. Models mergen wird nix.

Möglichkeit 1: Editoren müssen mit der 1-N-Model-Situation klarkommen.
Möglichkeit 2: Nur ein SimulationModel an zentraler Stelle, wie OT-Server aber
	im Java-Code. 
Möglichkeit 3: Static State x N, Dynamic State zentral.

M2 wäre am coolsten, weil es eine allgemeine Lösung ist:
- OpenDocumentHub: statischer Zugriff auf "offene" Dokumente; öffnen und schließen.
	Zusammenspiel mit OT?
Soll ein Editor festlegen, "wie" ein Dokument geöffnet wird, oder ist das
Editor-unabhängig? Vgl. SimVM in Texteditor, Simulator öffnen.
Oder gibt es getrennte Einträge im Document Hub für verschiedene Editoren?
Oder ist der DH eine Zwischenstufe, die *manche* Editoren zusammenfasst?

OpenDocumentHub -> DocumentModelManager.
M1 ist M3 in häßlich.
M3 ist Problem verlagert, da der Dynamic State die Lösung M2 benutzt und der
Static State praktisch nicht editierbar ist. Das geht nur solange gut, bis nicht
doch ein zweiter *echter* Editor gebraucht wird.

Also: Lösung M2. Allerdings noch Probleme mit Clustering. Textfiles sind aktuell
Sonderlösung; der OT-Server ist zwar genau so ein Document Model, aber fällt
rein formal aus dem Schema.

Clustering:
Verschiedene Webserver greifen auf dasselbe Dokument zu. Das "document model"
muss also entweder
- nur ein Proxy sein (DocumentAccess statt DocumentModel)
- oder eine selbst-synchronisierende Kopie
aber damit selbst-synchro funktioniert wird es höchst wahrscheinlich einen zentralen
Server geben, der das "master" dokument hält (n-to-n synchro zu kompliziert)
und dann läuft es auf proxy raus.

Wie würde denn auf abstrakter Ebene z.B. das Rendern einer SimVM im Cluster laufen,
wenn der Webserver nicht der Document-Owner ist? -> wäre ziemlicher Mist. Man
müsste die Daten remote abrufen, aber dafür ist Wicket überhaupt nicht ausgelegt.
Eher: Ein Webserver mit UI hält soviele Daten lokal vor, dass er ohne remote
access rendern kann. Actions und neue Daten gehen dann Remote, und aus Browser-Sicht
in zwei Schritten: 1. AJAX-request zum triggern, 2. Websockets-Push wenn die Daten
da sind (als 1 Request wenn es "schnell" geht).

Das würde so aber bedeuten, dass für jeden Dokumenttyp (SimVM: Jede kleine
Erweiterung) Code für den Dokumenten-Server, ein Proxy *und* das UI geschrieben
werden müssen. Erste Idee: Proxy und UI besteht aus Standardbibliothek von
Komponenten, und der Dokumenten-Server liefert eine Struktur (z.B. JSON),
die diese Standardkomponenten nur noch benutzt/zusammensetzt. Der Dokumentenserver
sollte aber soweit möglich pro Client Stateless sein, also nur ein globaler State,
weil das per Definition innerhalb eines Servers nicht-parallel passiert (wobei
verschiedene Dokumente auf verschiedenen Servern liegen könnten; es wäre aber
auch einfacher, wenn ein Dokument pro Client stateless ist). Oder zumindest
minimaler per-client state, siehe OT-Server.

--- idee ---
- Interface IDocumentModel
- Klasse DocumentModelManager
	- <T extends IDocumentModel> getDocumentModel(Class<T> clazz);
		Liefert ein globales 
- garbage collection für document models?





