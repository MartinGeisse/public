
PluginBundle: JAR-file, entspricht "Plugin" in Eclipse
Plugin: Sammlung von PluginBundles, entspricht (glaub ich) "Feature" in Eclipse
	+ Name, Doku usw.

Ein Plugin kann sein:
- Ergebnis eines Auto-Build eines Plugin-Projekts
	(je Build entsteht ein "Plugin" und N Bundles)
- Von einem User veröffentlichtes Plugin
	(je Release entsteht ein "Plugin" und N Bundles)
- Zentral veröffentlichtes Plugin
	(je Release entsteht ein "Plugin" und N Bundles,
	gemeinsamer Release-Prozess mit vorherigem Punkt)

Plugin und Bundles sind die Quelle, aus der ein Plugin-Classloader seine
Klassen lädt. Entspricht N JAR-files. Plugin-Datensätze und Bundle-Datensätze
sind immutable und werden, soweit machbar, gemeinsam benutzt. (Gerade für
Autobuild sollten dann auch die nicht mehr benutzten Datensätze aufgeräumt
werden). Die verschiedenen Arten, wie Plugins in Erscheinung treten
(Veröffentluchung, Autobuild, ...) sind dann verschiedene Arten, wie die
Plugin/Bundle Datensätze *benutzt* werden, aber entsprechen keinen Unterschieden
in den Datensätzen selbst. (Einzige Ausnahme: Die Datensätze können die Art der
Verwendung in einem Feld speichern, um das Refcounting und Aufräumen zu
optimieren, sowie als zusätzliche Sicherheitsprüfung -- es ändert aber nichts
am Verhalten des Plugins). 

Die verschiedenen Verwendungen sind dann in anderen Datensätzen festgehalten:
- PluginRelease (user, plugin, releaseDate, comment)
- PluginAutobuild (workspace, plugin, buildDate)

-----------------------------------

Implementierung:

ClassLoader.findClass() ruft ClassLoader.defineClass() mit eigens erzeugter
ProtectionDomain. Bisher unklar, ob die Permissions direkt in der ProtectionDomain
gepsichert werden sollen oder aus der Policy kommen sollen. Vermutlich
einfacher, indem in der ProtectionDomain eingespeichert, weil das System
nicht sehr dynamisch sein muss. ClassLoader ist bekannt, keine Principals.
CodeSource: Keine Zertifikate; URL könnte nach einem einheitlichen Schema für
Plugin-Bundle-URLs gebaut sein.

URLs:
	webide-resource:bar
		relativer Pfad
	webide-resource:/foo/bar
		absoluter Pfad innerhalb eines Workspace
	webide-resource://12/foo/bar
		absoluter Pfad inkl. Workspace-DB-ID
	webide-plugin://55
		für ein Plugin; 55 = Plugin-DB-ID
	webide-plugin://55/com.foobar.myplugin
		für ein Bundle; 55 = Plugin-DB-ID, com.foobar.myplugin = bundle name
	webide-plugin-bundle://123
		für ein Bundle; 123 = PluginBundle-DB-ID

ClassLoader.findClass() bekommt den ClassFile über einen PluginClassFileFetcher.
Einfache Impl. reicht, aber später kann da der gesamte JAR-File gecached werden
(zeitlich unbegrenzt, aber max. Speicherverbrauch für den gesamten Cache).

Angepeilter Test: Plugin mit MenuItem -> System.out.println("Hello World");

-----------------------------------

Wofür wird jeweils ein eigener ClassLoader und wofür eine ProtectionDomain gebaut?

CL:
- für separate JAR-Files, um diese gegeneinander abzuschirmen
- für separate Benutzer? Wäre von daher doof, weil dann derselbe Code für verschiedene
  User mehrfach geladen werden muss. Vorteil wären die mehrfach vorhandenen Static
  Variables -> Abschirmung. Wobei sich Plugins wegen Clustering eh nicht auf Static
  Vars verlassen sollten. Geheimhaltung ist zwar "gefährdet", aber an dieser Stelle
  eh nicht mehr garantiert. Letztendlich wird jedes Plugin irgendwie Daten "durchsickern"
  lassen können, zumindest nach dem ersten Design, also sollte man sich wenn man
  Geheimhaltung will nur vertrauenswürdige Plugins installieren. Zum Beispiel müssen Plugins
  ja auch die Möglichkeit haben, zu Dritt-Webseiten Kontakt aufzunehmen, wegen ihren
  Features.

Also: Ein ClassLoader je Eintrag in der plugin_bundles Tabelle.

Vorerst aber der Einfachheit halber mit wegwerf-Classloders.

-----------------------------------

Flag in users, ob extension_bindings (noch) stimmen. Da plugins und plugin_bundles
immutable sind, kann das nur durch Änderungen in der user_plugins zustandekommen.

-----------------------------------

Nächste Schritte:

Hello World kann jetzt getestet werden, auch ohne Plugin State.

Danach Plugin State, oder halt Workspace Folders.
