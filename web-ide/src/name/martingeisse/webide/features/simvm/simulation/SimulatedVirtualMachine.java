/**
 * Copyright (c) 2010 Martin Geisse
 *
 * This file is distributed under the terms of the MIT license.
 */

package name.martingeisse.webide.features.simvm.simulation;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

import name.martingeisse.webide.application.WebIdeApplication;
import name.martingeisse.webide.document.Document;
import name.martingeisse.webide.document.IDocumentBody;
import name.martingeisse.webide.features.simvm.model.SimulationModel;
import name.martingeisse.webide.ipc.EventListenerMetadata;
import name.martingeisse.webide.ipc.IIpcEventListener;
import name.martingeisse.webide.ipc.IIpcEventOutbox;
import name.martingeisse.webide.ipc.IpcEvent;
import name.martingeisse.webide.ipc.IpcEventBus;
import name.martingeisse.webide.resources.ResourceHandle;

import org.apache.wicket.atmosphere.EventBus;

/**
 * Represents a SimVM virtual machine, including its definition, runtime state,
 * and simulation thread. Each instance builds its own {@link SimulationModel}
 * and keeps associated state. This virtual machine is globally available
 * as a document, backed and identified by its definition file.
 * 
 * The document is long-living and "survives" terminating the simulation; the
 * only invariant between the document and the simulation (and its simulation
 * thread) is that if a simulation thread exists, then the document must also
 * exist.
 * 
 * All simulation control methods are implemented as events posted to the
 * simulation thread. This implies that immediate feedback is not available.
 * Callers should also be prepared for crashed simulations that cannot respond
 * to such events properly.
 * 
 * Neither terminating nor suspending the simulation deletes its
 * "simulated-persistent" state (e.g. simulated disk contents). Terminating the
 * simulation does delete its "simulated-volatile" state, though. 
 * 
 * Events generated by the simulation are published both through the
 * outputEventBus available from this class, and as a broadcast
 * Wicket-Atmosphere message using {@link SimulationEventMessage}.
 * (Filtered) Atmosphere messages are used to update simulator UI pages since
 * they don't require fiddling with registration/deregistration
 * when the page is serialized.
 */
public final class SimulatedVirtualMachine implements IDocumentBody {

	/**
	 * the document
	 */
	private Document document;

	/**
	 * the simulationModel
	 */
	private SimulationModel simulationModel;
	
	/**
	 * the state
	 */
	private volatile SimulationState state;
	
	/**
	 * the simulationThread
	 */
	private SimulationThread simulationThread;
	
	/**
	 * the eventQueue
	 */
	private BlockingQueue<IpcEvent> eventQueue;
	
	/**
	 * the outputEventBus
	 */
	private IpcEventBus outputEventBus;
	
	/**
	 * Getter method for the document.
	 * @return the document
	 */
	public Document getDocument() {
		return document;
	}

	/**
	 * Getter method for the simulationModel.
	 * @return the simulationModel
	 */
	public SimulationModel getSimulationModel() {
		return simulationModel;
	}

	/**
	 * Getter method for the state.
	 * @return the state
	 */
	public SimulationState getState() {
		return state;
	}
	
	/**
	 * Setter method for the state.
	 * @param state the state to set
	 */
	void setState(SimulationState state) {
		this.state = state;
	}
	
	/**
	 * Getter method for the outputEventBus.
	 * @return the outputEventBus
	 */
	public IpcEventBus getOutputEventBus() {
		return outputEventBus;
	}
	
	/* (non-Javadoc)
	 * @see name.martingeisse.webide.document.IDocumentBody#initialize(name.martingeisse.webide.document.Document)
	 */
	@Override
	public synchronized void initialize(Document document) {
		
		// initialize fields
		this.document = document;
		this.simulationModel = null;
		this.state = SimulationState.STOPPED;
		this.simulationThread = null;
		this.eventQueue = null;
		this.outputEventBus = new IpcEventBus();
		
		// publish output events to all pages to enable push-updates
		this.outputEventBus.addListener(new IIpcEventListener() {
			
			@Override
			public void handleEvent(IpcEvent event) {
				EventBus.get(WebIdeApplication.getCrossThreadInstance()).post(new SimulationEventMessage(SimulatedVirtualMachine.this, event));
			}
			
			@Override
			public EventListenerMetadata getMetadata() {
				return null;
			}
			
		});
		
		// initialize the simulation model
		this.simulationModel = new SimulationModel(document.getResourceHandle(), new IIpcEventOutbox() {
			@Override
			public void sendEvent(IpcEvent event) {
				outputEventBus.dispatch(event);
			}
		});

	}

	/* (non-Javadoc)
	 * @see name.martingeisse.webide.document.IDocumentBody#load(name.martingeisse.webide.resources.ResourceHandle)
	 */
	@Override
	public synchronized void load(ResourceHandle resourceHandle) {
	}

	/* (non-Javadoc)
	 * @see name.martingeisse.webide.document.IDocumentBody#save(name.martingeisse.webide.resources.ResourceHandle)
	 */
	@Override
	public synchronized void save(ResourceHandle resourceHandle) {
	}

	/**
	 * Starts the simulation. Does nothing if the simulation is already running,
	 * since that can easily happen due to race conditions. The thread will
	 * start up in paused mode; use {@link #resume()} to un-pause.
	 */
	public synchronized void startSimulation() {
		if (state != SimulationState.STOPPED) {
			return;
		}
		this.eventQueue = new LinkedBlockingQueue<IpcEvent>();
		this.simulationThread = new SimulationThread(this);
		this.state = SimulationState.PAUSED;
		simulationThread.start();
	}
	
	/**
	 * Pauses this simulation. The simulation stops simulating and waits for
	 * further method calls. Has no effect if the simulation is already paused.
	 */
	public void pause() {
		postEvent(new IpcEvent(SimulationEvents.EVENT_TYPE_PAUSE, this, null));
	}

	/**
	 * Performs a single simulation step. The exact meaning depends on the
	 * simulation model. Has no effect if the simulation is currently running.
	 */
	public void step() {
		postEvent(new IpcEvent(SimulationEvents.EVENT_TYPE_STEP, this, null));
	}

	/**
	 * Resumes simulation from "paused" state.
	 * Has no effect if the simulation is currently running.
	 */
	public void resume() {
		postEvent(new IpcEvent(SimulationEvents.EVENT_TYPE_RESUME, this, null));
	}

	/**
	 * Suspends this simulation, writing its runtime state to disk. This object
	 * becomes stale by using this method and should not be used anymore.
	 */
	public void suspend() {
		postEvent(new IpcEvent(SimulationEvents.EVENT_TYPE_SUSPEND, this, null));
	}

	/**
	 * Terminates this simulation, deleting all runtime state. This object
	 * becomes stale by using this method and should not be used anymore.
	 */
	public void terminate() {
		postEvent(new IpcEvent(SimulationEvents.EVENT_TYPE_TERMINATE, this, null));
	}

	/**
	 * Adds an event to the event queue for this simulation.
	 * @param event the event to post
	 */
	public void postEvent(final IpcEvent event) {
		if (eventQueue != null) {
			eventQueue.add(event);
		}
	}
	
	/**
	 * Fetches an event. If no event is available, then if the "block" flag is set,
	 * this method blocks until an event arrives, otherwise it returns null.
	 * This method is used by the simulation thread.
	 */
	IpcEvent fetchEvent(final boolean block) throws InterruptedException {
		if (block) {
			return eventQueue.take();
		} else {
			return eventQueue.poll();
		}
	}

	/**
	 * Detaches the simulation thread from this VM. This is called by the
	 * simulation thread on exit, just before it posts its exit event.
	 */
	synchronized void detachSimulationThread() {
		this.eventQueue = null;
		this.simulationThread = null;
		this.state = SimulationState.STOPPED;
	}
	
}
