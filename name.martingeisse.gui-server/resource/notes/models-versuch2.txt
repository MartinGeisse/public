
Idee war: <gui:with-models><gui:model ...>
Das ist schwergewichtig, wenn man nur 1 Model will, aber passend bei 2+ Models.
Außerdem ist es unflexibel, weil nur 1 Art von Model, nämlich Backend-HTTP,
angegeben werden kann.

Idee 1: <gui:httpModel src="http://backend/foo">...usage...</gui:httpModel>
Der Tagname gibt an, *dass* ein Model verwendet wird und *welches*. Der Scope
ist durch das Element mit angegeben und kann nicht "aus einem Repeater herausleaken"
oder ähnliche kritische Probleme.
-> Problem #1 die Schachtelung ist bei mehreren Models evtl. etwas unhandlich
-> Problem #2 evtl viele verschiedene Tagnamen für verschiedene Models
	-> das sollte nicht so das Problem sein. Außerdem macht es Sinn, für Standardmodels
	einen eigenen Namespace einzuführen:
	
	<model:http name="m" src="http://backend/foo">
		<gui:html model="m.subjectLine" />
	</model>

	Hier wird durch den model-Namespace der Tagsalat lesbarer. Per model="m.subjectLine"
	lassen sich implizite PropertyModels definieren.
	->
	Das sieht erst mal wie eine gute Idee aus. Wird vermutlich am besten sein, das
	erst mal auszuprobieren.
	
Nächste Frage: Definiert ein <model:*> Element auch eine Wicket-Component, oder nur ein
Model? Implementierung per Model wäre jedenfalls "straightforward", mit einem
WebMarkupContainer, der genau dieses Model angehängt hat. Auswirkungen der extra-Container
auf die Performance unklar, aber man sollte nicht voreilig optimieren. Andere negative
Auswirkungen bisher nicht in Sicht.

Auswirkungen eines Repeaters sind dann einfach zu definieren: Sie bewirken auch eine
implizite Model-definition.

