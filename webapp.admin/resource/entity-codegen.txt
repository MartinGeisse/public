
Überlegungen:
- Verwendung als DataRow wichtig für Admin-Bereich
- Verwendung als Bean wichtig für Application-Code
- es sollte dasselbe Objekt sein, um Model/Wrapper-Konvertierungsproblem zu vermeiden
- wenn auf Basis einer DataRow -> Subklasse für getter/setter
- wenn auf Basis einer Bean -> Interface für DataRow-Verhalten
- Der QueryDSL-Codegenerator muss ggf. angepasst werden

...

Bisherige Überlegungen (Stand 6.10. 14:00 noch im Git) haben ergeben:

	* Entity Instances mit generiertem Code sind Bean-Klassen, keine DataRow-Subklassen.
	  QueryDSL füllt diese per direktem Zugriff auf die Fields per Reflection.
	* Index-G/S werden z.B. per switch abgebildet. G/S für ganze Rows sind denkbar. Beides
	  wäre Teil eines IDataRow

Nachteil: Generierte Klassen können sich nicht automatisch an DB-Änderungen anpassen:
Auch der Generische Code sieht die Änderungen dann nicht! Auch wenn der generische
Code per DataRow lädt: Es kann passieren, dass App-Code per Q-Klasse lädt und dann
an den generischen Code übergibt. Neue Felder würden dann z.B. fehlen. Das Hauptproblem
ist also, dass Q-Klassen neue Felder gar nicht erst laden. Lösungen:
- Q-Klassen doch auf DataRow umstellen. Umständlich.
- Für generierte Klassen werden Änderungen erst mit neu generieren gültig. Für
  Tabellen ohne generierte Klassen sofort. Etwas unschön aber nicht dramatisch.

Weitere wichtige Feststellung ist, dass wenn man den RelationalPath (also die Instanz
der Q-Klasse) hat, man auch die Java-Klasse bekommt. Diese ist auch das, was eine
"Bean-Klasse mit generiertem Code gegenüber einer DataRow-Subklasse" ausmacht. Folgende
wesentliche Festlegung ist also möglich:

	* Eine Entity Instance benutzt generierten Code und folglich eine per Field-Reflection
	  gefüllte Java Bean, gdw. dafür ein RelationalPath vorliegt, ansonsten benutzt sie
	  eine DataRow. Eine angepasste DataRow-Subklasse je Entity ist immer noch möglich,
	  basiert aber grundsätzlich auf Arrays und hat keine weitere QueryDSL-Unterstützung.
	  Sie werden per "SELECT *" mit Reihenfolge-Check geladen. Die Java Beans dagegen
	  werden wie in QueryDSL üblich behandelt. 

---

Nächste Schritte:
- IDataRow definieren
- Codegenerator: Beans müssen IDataRow implementieren.
- woher kommt die Feldreihenfolge? Aus dem Codegenerator oder beim Startup festgelegt?
- muss der generische Code (EntityDescriptor) mit der Q-Klasse configuriert werden?
- wenn es eine generierte Klasse gibt: Lädt der generische Code dann per DataRow
  oder über die Q-Klasse?
  
  Gefühl sagt: Sinnvoll ist: Per Q-Klasse, da der DataRow-Code eine evtl.
  Änderung in der DB schon sehen würde, diese aber in der IDataRow so nicht
  vorfindet. Ähnliches gilt für Änderungen an den Q-Klassen ggü. dem Standard,
  was mit einem custom Codegen denkbar ist.
  
  	Problem: Wie kommt der EntityDescriptor an die Q-Klasse? Die manuell alle übergeben
  	ist fies. Der Code-Generator könnte da aber nachhelfen. Außerdem gibt es schon
  	einen Mechanismus, damit der ED an die Bean-Klassen kommt (über die muss er so
  	oder so Bescheid wissen). Dann könnte der Codegen eine Annotation an die
  	Bean-Klasse taggen, die auf die Q-Klasse verweist.
  
  Der Grundgedanke ist dann:
  - Wenn Codegen, dann Beans und Q-Klassen. Dann werden immer nur die Q-Klassen
    verwendet, sowohl von generischem Code (dieser bekommt Zugriff auf die QKs)
    als auch von spezifischem Code.
  - Wenn kein Codegen, dann nur DataRow mit konstant gehaltener Reihenfolge.

  Dann muss das Verhalten "ResultSet mit bekannter Reihenfolge" abstrahiert werden;
  das gilt nur noch für Tabellen ohne Codegen.
  
  Die Frage ist immer: Ist es die richtige Entscheidung, im generischen Code für
  Tabellen mit Codegen die Q-Klassen anstatt ResultSet+DataRow mit bekannter und
  fest gehaltener Reihenfolge zu benutzen? Es erscheint weniger aufwändig und cooler
  und vermeidet Probleme falls die Q-Klassen davon abweichen, denn in letzterem
  Fall wird der Benutzer das Verhalten der Q-Klassen erwarten, weil er nur das
  kennt. Die Frage ist: sollten die Q-Klassen überhaupt abweichen können, und gibt
  es andere Probleme, die auftreten könnten?
  
  -> "do the simplest thing..." -> generischer Code bekommt Zugriff auf die
  Q-Klassen, bis etwas wesentliches dagegenspricht.
  
  Ist auch simpler, denn es gibt nur zwei Fälle (generisch/datarow/bekannte Reihenfolge,
  spezfisch/beans/q-klassen) statt drei Fälle (generisch, spezifisch,
  gen/spez mix in verschiedenen Codeteilen).

-------

Aktuelle Überlegung ist sogar, ob man auf die DataRow-Implementierung für Entities
komplett verzichten kann, also nur Entities mit generierten Klassen nimmt.
Überlegungen dazu:

- IDataRow macht weiterhin Sinn für generische Tabellen, kann aber auch durch
  Reflection ersetzt werden.
- DataRow macht weiterhin Sinn für ResultSets aus Queries für einzelne Felder
  statt ganzer Entities. 
- Queries mit einzelnen Feldern machen auch für generische Tabellen Sinn.
  Da werden die Felder aber aufgezählt, d.h. DataRow-Implementierung für
  Entities auch hier nicht sinnvoll.
- wegfallen würde die Klasse EntityInstance. Die generierten Bean-Klassen
  würden direkt IDataRow implementieren (oder halt Reflection).

Gefühl sagt: die Frage ist falsch gestellt. Wenn die einzelnen Komponenten erst
mal richtig mit IDataRow u.ä. abgekoppelt sind, dann hat DataRow vs. Bean nur
noch auf wenige Codestücke Auswirkungen. Dann könnte man DataRows auch ermöglichen,
einfach weil es geht, oder weglassen um den EntityDescriptor zu vereinfachen.

Außer dem Raw-INSTANCE-Panel greift aktuell kein Code auf die Felder per eigener
Reihenfolge zu, nur per Name. Das RawTablePanel geht auch über den Namen (wie
in der Raw-Table-Property-Order definiert). Die DB-Reihenfolge könnte der Codegen
auch noch hinterlegen. Einziger Grund, den Codegen zu umgehen, wäre also, um
den Aufwand für Codegen zu sparen und um Änderungen "direkt" zu sehen ohne den
Codegen zu starten. Trotzdem natürlich cool wenn es gehen würde.

Erst mal die Interfaces bauen und alles umstellen.



