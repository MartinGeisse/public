
Überlegungen:
- Verwendung als DataRow wichtig für Admin-Bereich
- Verwendung als Bean wichtig für Application-Code
- es sollte dasselbe Objekt sein, um Model/Wrapper-Konvertierungsproblem zu vermeiden
- wenn auf Basis einer DataRow -> Subklasse für getter/setter
- wenn auf Basis einer Bean -> Interface für DataRow-Verhalten
- Der QueryDSL-Codegenerator muss ggf. angepasst werden

...

Bisherige Überlegungen (Stand 6.10. 14:00 noch im Git) haben ergeben:

	* Entity Instances mit generiertem Code sind Bean-Klassen, keine DataRow-Subklassen.
	  QueryDSL füllt diese per direktem Zugriff auf die Fields per Reflection.
	* Index-G/S werden z.B. per switch abgebildet. G/S für ganze Rows sind denkbar. Beides
	  wäre Teil eines IDataRow

Nachteil: Generierte Klassen können sich nicht automatisch an DB-Änderungen anpassen:
Auch der Generische Code sieht die Änderungen dann nicht! Auch wenn der generische
Code per DataRow lädt: Es kann passieren, dass App-Code per Q-Klasse lädt und dann
an den generischen Code übergibt. Neue Felder würden dann z.B. fehlen. Das Hauptproblem
ist also, dass Q-Klassen neue Felder gar nicht erst laden. Lösungen:
- Q-Klassen doch auf DataRow umstellen. Umständlich.
- Für generierte Klassen werden Änderungen erst mit neu generieren gültig. Für
  Tabellen ohne generierte Klassen sofort. Etwas unschön aber nicht dramatisch.

Weitere wichtige Feststellung ist, dass wenn man den RelationalPath (also die Instanz
der Q-Klasse) hat, man auch die Java-Klasse bekommt. Diese ist auch das, was eine
"Bean-Klasse mit generiertem Code gegenüber einer DataRow-Subklasse" ausmacht. Folgende
wesentliche Festlegung ist also möglich:

	* Eine Entity Instance benutzt generierten Code und folglich eine per Field-Reflection
	  gefüllte Java Bean, gdw. dafür ein RelationalPath vorliegt, ansonsten benutzt sie
	  eine DataRow. Eine angepasste DataRow-Subklasse je Entity ist immer noch möglich,
	  basiert aber grundsätzlich auf Arrays und hat keine weitere QueryDSL-Unterstützung.
	  Sie werden per "SELECT *" mit Reihenfolge-Check geladen. Die Java Beans dagegen
	  werden wie in QueryDSL üblich behandelt. 

---

Nächste Schritte:
- IDataRow definieren
- Codegenerator: Beans müssen IDataRow implementieren.
- woher kommt die Feldreihenfolge? Aus dem Codegenerator oder beim Startup festgelegt?
- muss der generische Code (EntityDescriptor) mit der Q-Klasse configuriert werden?
- wenn es eine generierte Klasse gibt: Lädt der generische Code dann per DataRow
  oder über die Q-Klasse?
  
  Gefühl sagt: Sinnvoll ist: Per Q-Klasse, da der DataRow-Code eine evtl.
  Änderung in der DB schon sehen würde, diese aber in der IDataRow so nicht
  vorfindet. Ähnliches gilt für Änderungen an den Q-Klassen ggü. dem Standard,
  was mit einem custom Codegen denkbar ist.
  
  	Problem: Wie kommt der EntityDescriptor an die Q-Klasse? Die manuell alle übergeben
  	ist fies. Der Code-Generator könnte da aber nachhelfen. Außerdem gibt es schon
  	einen Mechanismus, damit der ED an die Bean-Klassen kommt (über die muss er so
  	oder so Bescheid wissen). Dann könnte der Codegen eine Annotation an die
  	Bean-Klasse taggen, die auf die Q-Klasse verweist.
  
  Der Grundgedanke ist dann:
  - Wenn Codegen, dann Beans und Q-Klassen. Dann werden immer nur die Q-Klassen
    verwendet, sowohl von generischem Code (dieser bekommt Zugriff auf die QKs)
    als auch von spezifischem Code.
  - Wenn kein Codegen, dann nur DataRow mit konstant gehaltener Reihenfolge.

  Dann muss das Verhalten "ResultSet mit bekannter Reihenfolge" abstrahiert werden;
  das gilt nur noch für Tabellen ohne Codegen.
  
  Die Frage ist immer: Ist es die richtige Entscheidung, im generischen Code für
  Tabellen mit Codegen die Q-Klassen anstatt ResultSet+DataRow mit bekannter und
  fest gehaltener Reihenfolge zu benutzen? Es erscheint weniger aufwändig und cooler
  und vermeidet Probleme falls die Q-Klassen davon abweichen, denn in letzterem
  Fall wird der Benutzer das Verhalten der Q-Klassen erwarten, weil er nur das
  kennt. Die Frage ist: sollten die Q-Klassen überhaupt abweichen können, und gibt
  es andere Probleme, die auftreten könnten?
  
  -> "do the simplest thing..." -> generischer Code bekommt Zugriff auf die
  Q-Klassen, bis etwas wesentliches dagegenspricht.
  
  Ist auch simpler, denn es gibt nur zwei Fälle (generisch/datarow/bekannte Reihenfolge,
  spezfisch/beans/q-klassen) statt drei Fälle (generisch, spezifisch,
  gen/spez mix in verschiedenen Codeteilen).


  
  
  
  
  