
Überlegungen:
- Verwendung als DataRow wichtig für Admin-Bereich
- Verwendung als Bean wichtig für Application-Code
- es sollte dasselbe Objekt sein, um Model/Wrapper-Konvertierungsproblem zu vermeiden
- wenn auf Basis einer DataRow -> Subklasse für getter/setter
- wenn auf Basis einer Bean -> Interface für DataRow-Verhalten
- Der QueryDSL-Codegenerator muss ggf. angepasst werden

...

Bisherige Überlegungen (Stand 6.10. 14:00 noch im Git) haben ergeben:

	* Entity Instances mit generiertem Code sind Bean-Klassen, keine DataRow-Subklassen.
	  QueryDSL füllt diese per direktem Zugriff auf die Fields per Reflection.
	* Index-G/S werden z.B. per switch abgebildet. G/S für ganze Rows sind denkbar. Beides
	  wäre Teil eines IDataRow

Nachteil: Generierte Klassen können sich nicht automatisch an DB-Änderungen anpassen:
Auch der Generische Code sieht die Änderungen dann nicht! Auch wenn der generische
Code per DataRow lädt: Es kann passieren, dass App-Code per Q-Klasse lädt und dann
an den generischen Code übergibt. Neue Felder würden dann z.B. fehlen. Das Hauptproblem
ist also, dass Q-Klassen neue Felder gar nicht erst laden. Lösungen:
- Q-Klassen doch auf DataRow umstellen. Umständlich.
- Für generierte Klassen werden Änderungen erst mit neu generieren gültig. Für
  Tabellen ohne generierte Klassen sofort. Etwas unschön aber nicht dramatisch.

Weitere wichtige Feststellung ist, dass wenn man den RelationalPath (also die Instanz
der Q-Klasse) hat, man auch die Java-Klasse bekommt. Diese ist auch das, was eine
"Bean-Klasse mit generiertem Code gegenüber einer DataRow-Subklasse" ausmacht. Folgende
wesentliche Festlegung ist also möglich:

	* Eine Entity Instance benutzt generierten Code und folglich eine per Field-Reflection
	  gefüllte Java Bean, gdw. dafür ein RelationalPath vorliegt, ansonsten benutzt sie
	  eine DataRow. Eine angepasste DataRow-Subklasse je Entity ist immer noch möglich,
	  basiert aber grundsätzlich auf Arrays und hat keine weitere QueryDSL-Unterstützung.
	  Sie werden per "SELECT *" mit Reihenfolge-Check geladen. Die Java Beans dagegen
	  werden wie in QueryDSL üblich behandelt. 

---

Nächste Schritte:
- IDataRow definieren
- Codegenerator: Beans müssen IDataRow implementieren.
- woher kommt die Feldreihenfolge? Aus dem Codegenerator oder beim Startup festgelegt?
- muss der generische Code (EntityDescriptor) mit der Q-Klasse configuriert werden?
- wenn es eine generierte Klasse gibt: Lädt der generische Code dann per DataRow
  oder über die Q-Klasse?
  
  Gefühl sagt: Sinnvoll ist: Per Q-Klasse, da der DataRow-Code eine evtl.
  Änderung in der DB schon sehen würde, diese aber in der IDataRow so nicht
  vorfindet. Ähnliches gilt für Änderungen an den Q-Klassen ggü. dem Standard,
  was mit einem custom Codegen denkbar ist.
  
  	Problem: Wie kommt der EntityDescriptor an die Q-Klasse? Die manuell alle übergeben
  	ist fies. Der Code-Generator könnte da aber nachhelfen. Außerdem gibt es schon
  	einen Mechanismus, damit der ED an die Bean-Klassen kommt (über die muss er so
  	oder so Bescheid wissen). Dann könnte der Codegen eine Annotation an die
  	Bean-Klasse taggen, die auf die Q-Klasse verweist.
  
  Der Grundgedanke ist dann:
  - Wenn Codegen, dann Beans und Q-Klassen. Dann werden immer nur die Q-Klassen
    verwendet, sowohl von generischem Code (dieser bekommt Zugriff auf die QKs)
    als auch von spezifischem Code.
  - Wenn kein Codegen, dann nur DataRow mit konstant gehaltener Reihenfolge.

  Dann muss das Verhalten "ResultSet mit bekannter Reihenfolge" abstrahiert werden;
  das gilt nur noch für Tabellen ohne Codegen.
  
  Die Frage ist immer: Ist es die richtige Entscheidung, im generischen Code für
  Tabellen mit Codegen die Q-Klassen anstatt ResultSet+DataRow mit bekannter und
  fest gehaltener Reihenfolge zu benutzen? Es erscheint weniger aufwändig und cooler
  und vermeidet Probleme falls die Q-Klassen davon abweichen, denn in letzterem
  Fall wird der Benutzer das Verhalten der Q-Klassen erwarten, weil er nur das
  kennt. Die Frage ist: sollten die Q-Klassen überhaupt abweichen können, und gibt
  es andere Probleme, die auftreten könnten?
  
  -> "do the simplest thing..." -> generischer Code bekommt Zugriff auf die
  Q-Klassen, bis etwas wesentliches dagegenspricht.
  
  Ist auch simpler, denn es gibt nur zwei Fälle (generisch/datarow/bekannte Reihenfolge,
  spezfisch/beans/q-klassen) statt drei Fälle (generisch, spezifisch,
  gen/spez mix in verschiedenen Codeteilen).

-------

Aktuelle Überlegung ist sogar, ob man auf die DataRow-Implementierung für Entities
komplett verzichten kann, also nur Entities mit generierten Klassen nimmt.
Überlegungen dazu:

- IDataRow macht weiterhin Sinn für generische Tabellen, kann aber auch durch
  Reflection ersetzt werden.
- DataRow macht weiterhin Sinn für ResultSets aus Queries für einzelne Felder
  statt ganzer Entities. 
- Queries mit einzelnen Feldern machen auch für generische Tabellen Sinn.
  Da werden die Felder aber aufgezählt, d.h. DataRow-Implementierung für
  Entities auch hier nicht sinnvoll.
- wegfallen würde die Klasse EntityInstance. Die generierten Bean-Klassen
  würden direkt IDataRow implementieren (oder halt Reflection).

Gefühl sagt: die Frage ist falsch gestellt. Wenn die einzelnen Komponenten erst
mal richtig mit IDataRow u.ä. abgekoppelt sind, dann hat DataRow vs. Bean nur
noch auf wenige Codestücke Auswirkungen. Dann könnte man DataRows auch ermöglichen,
einfach weil es geht, oder weglassen um den EntityDescriptor zu vereinfachen.

Außer dem Raw-INSTANCE-Panel greift aktuell kein Code auf die Felder per eigener
Reihenfolge zu, nur per Name. Das RawTablePanel geht auch über den Namen (wie
in der Raw-Table-Property-Order definiert). Die DB-Reihenfolge könnte der Codegen
auch noch hinterlegen. Einziger Grund, den Codegen zu umgehen, wäre also, um
den Aufwand für Codegen zu sparen und um Änderungen "direkt" zu sehen ohne den
Codegen zu starten. Trotzdem natürlich cool wenn es gehen würde.

Erst mal die Interfaces bauen und alles umstellen.

Eine viel wesentlichere Überlegung ist: Kann das Fetchen von DataRow vs. Q-Klasse
transparent gemacht werden? Wenn nicht, dann ist damit sofort klar: Immer
generierter Code. Wesentlich sind hier z.B., ob WHERE-Klauseln transparent
formuliert werden können (immer der gleiche AS-Alias, unabhängig von DataRow
vs. Q-Klasse). Wenn das nicht so ist, dann sind auf einen Schlag so große
Probleme da, dass es sich nicht mehr lohnt, beides umzusetzen.

WHERE-Klauseln werden, wenn Q-Klassen vorhanden sind, vom Anwendungscode mit
denen formuliert. Also muss der generische Code gleichartiges tun -> das geht.
Der generische Code hat Zugriff auf die Q-Klassen und kann diese benutzen,
um WHERE-Klauseln zu bauen. Dafür müssen ein paar Sachen geändert werden.
Die Frage ist: Wie aufwändig ist es, wenn gleichzeitig die Variante ohne
Q-Klassen weiter funktionieren muss? Das Zusammenbauen der WHERE-Klauseln hat
das jetzt gleich komplizierter gemacht.

Allerdings gilt: Der generische Code muss jetzt immer in der Lage sein, die
Q-Klassen zu benutzen. *Das* ist der komplizierte Teil. Gleichzeitig eine
Alternative offenzuhalten ist evtl. gar nicht so kompliziert. Die WHERE
Klauseln müssen im Falle der Q-Klassen über den RelationalPath aus dem
Entity-Descriptor gebaut werden. Also könnte der EntityDescriptor eine
Factory-Methode für
(1) Paths
(2) EntityConditions
bekommen. Ob diese Factory jetzt intern den RelationalPath aus der Q-Klasse
nimmt oder selbst baut (für DataRow-Zugriff) ist nach außen egal. Wichtig ist
nur: Wenn die Q-Klasse da ist, muss sie auch benutzt werden, denn der 
App-Entwickler tut das auch -- und dann würden ansonsten Pfade verschiedener
Art gemischt.

Dann wird EntityDescriptor.ALIAS auch mehr oder weniger "private" -- äußerer
Code sollte das nicht verwenden, weil es nur in Code mit DataRow-Zugriff
gültig ist. Das ist ein guter Ansatzpunkt, um den Code umzustellen! Dito
die Verwendung von ResultSet. Die executeQuery() Methoden müssten eine
List<IDataRow> oder List<IEntityInstance> liefern. IEntityInstance klingt
erst mal wie eine gute Idee (z.B. mit getEntityId() zusätzlich zur IDataRow),
also mal einbauen und umstellen.
- IDataRow: DB-Results allgemein
- IEntityInstance extends IDataRow: DB-Results, die direkt einer Tabelle entsprechen

Ein weiterer Ansatzpunkt ist dann, den Codegen auf IEntityInstance umzustellen.

WICHTIG: Wenn generierter Code vorliegt, dann muss die Query auch die _ECHTE_
Q-Klasse benutzen und nicht nur einen RelationalPath mit derselben Tabelle
und demselben Typ. QueryDSL greift per Reflection auf die static-Felder dieser
Klasse zu!!!




