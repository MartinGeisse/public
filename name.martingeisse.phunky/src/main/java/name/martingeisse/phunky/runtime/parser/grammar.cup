
// ------------------------------------------------------------------------------------
// --- header information
// ------------------------------------------------------------------------------------

import java_cup.runtime.*;
import name.martingeisse.phunky.runtime.code.*;
import name.martingeisse.phunky.runtime.code.expression.*;
import name.martingeisse.phunky.runtime.code.statement.*;
import name.martingeisse.phunky.runtime.code.declaration.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.Symbol;
import java.util.List;
import java.util.ArrayList;

// scanner behavior
init with {:
:};
scan with {:
	return getScanner().next_token();
:};
parser code {:

	/* (non-Javadoc)
	 * @see java_cup.runtime.lr_parser#syntax_error(java_cup.runtime.Symbol)
	 */
	@Override
	public void syntax_error(final Symbol token) {
		if (token instanceof ComplexSymbol) {
			
			ComplexSymbol complexSymbol = (ComplexSymbol)token;
			int line = complexSymbol.getLeft().getLine();
			int column = complexSymbol.getLeft().getColumn();
			System.err.println("Syntax error at line " + line + ", col " + column + ", symbol " + complexSymbol.sym + ", value " + complexSymbol.value);
			
			System.err.print("Valid symbols at this point:");
			int state = ((Symbol)stack.peek()).parse_state;
			short[] actionRow = action_tab[state];
			for (int i=0; i<actionRow.length; i+=2) {
				if (actionRow[i + 1] != 0) {
					System.err.print(" " + actionRow[i]);
				}
			}
			System.err.println();
			
		} else {
			super.syntax_error(token);
		}
	}

:}

// ------------------------------------------------------------------------------------
// --- symbols
// ------------------------------------------------------------------------------------

// embedding in verbatim content
terminal String VERBATIM_CONTENT;

// punctuation (some of these can be operators too)
terminal OPENING_PARENTHESIS, CLOSING_PARENTHESIS;
terminal OPENING_CURLY_BRACE, CLOSING_CURLY_BRACE;
terminal OPENING_SQUARE_BRACKET, CLOSING_SQUARE_BRACKET;
terminal RIGHT_ARROW;
terminal SEMICOLON;
terminal SCOPE_RESOLUTION;
terminal QUESTION_MARK;
terminal COLON;
terminal COMMA;

// compilation object keywords
terminal FUNCTION, CLASS, INTERFACE;

// modifier keywords
terminal PUBLIC, PROTECTED, PRIVATE;
terminal ABSTRACT, FINAL, STATIC;

// statement keywords
terminal FOR, FOREACH, UNTIL, DO, WHILE, BREAK;
terminal IF, ELSEIF, ELSE;
terminal RETURN;
terminal THROW, TRY, CATCH, FINALLY;

// computation and logical operators
terminal PLUS, MINUS, TIMES, DIVIDE, MOD;
terminal LOGICAL_NOT, SHORTCUT_AND, SHORTCUT_OR;
terminal BITWISE_NOT, BITWISE_AND, BITWISE_OR, BITWISE_XOR;
terminal SHIFT_LEFT, SHIFT_RIGHT;

// comparison operators
terminal EQUAL, NOT_EQUAL, IDENTICAL, NOT_IDENTICAL;
terminal GREATER, LESS, GREATER_EQUAL, LESS_EQUAL;

// assignment operators
terminal ASSIGN;
terminal INCREMENT, DECREMENT;
terminal PLUS_ASSIGN, MINUS_ASSIGN, TIMES_ASSIGN, DIVIDE_ASSIGN, MOD_ASSIGN;
terminal BITWISE_AND_ASSIGN, BITWISE_OR_ASSIGN, BITWISE_XOR_ASSIGN;
terminal SHIFT_LEFT_ASSIGN, SHIFT_RIGHT_ASSIGN;

// special expressions
terminal ARRAY;
terminal SELF;
terminal PARENT;

// primitive expressions
terminal NULL_LITERAL;
terminal Boolean BOOLEAN_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal String STRING_LITERAL;
terminal String IDENTIFIER;
terminal String LOCAL_VARIABLE;

// non terminals
non terminal StatementSequence program;
non terminal List<Statement> statements;
non terminal Statement statement;
non terminal List<Expression> one_or_more_expressions;
non terminal List<Expression> expressions;
non terminal Expression expression;

// precedences
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right ASSIGN;
precedence left SEMICOLON; // needed for error recovery


// ------------------------------------------------------------------------------------
// --- rules
// ------------------------------------------------------------------------------------

start with program;

program ::=
	statements:sts
		{: RESULT = new StatementSequence(sts); :}
;
	
statements ::=
		{: RESULT = new ArrayList<Statement>(); :}
	| statements:sts statement:st
		{: sts.add(st); RESULT = sts; :}
;

statement ::=
	SEMICOLON
		{: RESULT = new NopStatement(); :} 
	| expression:e SEMICOLON
		{: RESULT = new ExpressionStatement(e); :} 
	| IDENTIFIER:id expression:e SEMICOLON
		{: RESULT = new ExpressionStatement(new FunctionCall(id, e)); :}
	| VERBATIM_CONTENT:c
		{: RESULT = new ExpressionStatement(new FunctionCall("echo", new LiteralExpression(c))); :}
	| OPENING_CURLY_BRACE statements:sts CLOSING_CURLY_BRACE
		{: RESULT = new StatementSequence(sts); :}
	| error SEMICOLON
		{: System.err.println("syntax error"); RESULT = new NopStatement(); :}
;

one_or_more_expressions ::=
	expression:ex
		{: RESULT = new ArrayList<Expression>(); RESULT.add(ex); :}
	| one_or_more_expressions:exs COMMA expression:ex
		{: exs.add(ex); RESULT = exs; :}
;

expressions ::=
		{: RESULT = new ArrayList<Expression>(); :}
	| one_or_more_expressions:exs
		{: RESULT = exs; :}
;

expression ::=
	BOOLEAN_LITERAL:e
		{: RESULT = new LiteralExpression(e); :}
	| INTEGER_LITERAL:e
		{: RESULT = new LiteralExpression(e); :}
	| STRING_LITERAL:e 
		{: RESULT = new LiteralExpression(e); :}
	| LOCAL_VARIABLE:e 
		{: RESULT = new LocalVariableExpression(e); :}
	| expression:e1 PLUS expression:e2
		{: RESULT = new BinaryExpression(e1, BinaryOperator.ADD, e2); :} 
	| expression:e1 MINUS expression:e2
		{: RESULT = new BinaryExpression(e1, BinaryOperator.SUBTRACT, e2); :} 
	| expression:e1 TIMES expression:e2
		{: RESULT = new BinaryExpression(e1, BinaryOperator.MULTIPLY, e2); :} 
	| expression:e1 DIVIDE expression:e2
		{: RESULT = new BinaryExpression(e1, BinaryOperator.DIVIDE, e2); :} 
	| expression:e1 MOD expression:e2
		{: RESULT = new BinaryExpression(e1, BinaryOperator.REMAINDER, e2); :} 
	| expression:e1 ASSIGN expression:e2
		{: RESULT = new BinaryExpression(e1, BinaryOperator.ASSIGN, e2); :}
	| IDENTIFIER:id OPENING_PARENTHESIS expressions:exs CLOSING_PARENTHESIS
		{: RESULT = new FunctionCall(id, exs.toArray(new Expression[exs.size()])); :}
	| error
		{: RESULT = new LiteralExpression(null); :}
;
