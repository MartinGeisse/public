//----------------------------------------------------
// The following code was generated by CUP v0.11b beta 20140220
// Fri May 30 23:11:06 CEST 2014
//----------------------------------------------------

package name.martingeisse.phunky.runtime.parser;

import java.util.ArrayList;
import java.util.List;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import java_cup.runtime.Symbol;
import name.martingeisse.phunky.runtime.code.expression.BinaryExpression;
import name.martingeisse.phunky.runtime.code.expression.BinaryOperator;
import name.martingeisse.phunky.runtime.code.expression.Expression;
import name.martingeisse.phunky.runtime.code.expression.FunctionCall;
import name.martingeisse.phunky.runtime.code.expression.LiteralExpression;
import name.martingeisse.phunky.runtime.code.expression.LocalVariableExpression;
import name.martingeisse.phunky.runtime.code.statement.ExpressionStatement;
import name.martingeisse.phunky.runtime.code.statement.NopStatement;
import name.martingeisse.phunky.runtime.code.statement.Statement;
import name.martingeisse.phunky.runtime.code.statement.StatementSequence;

/** CUP v0.11b beta 20140220 generated parser.
  * @version Fri May 30 23:11:06 CEST 2014
  */
@SuppressWarnings("all")
public class Parser extends java_cup.runtime.lr_parser {

	/** Default constructor. */
	public Parser() {
		super();
	}

	/** Constructor which sets the default scanner. */
	public Parser(final java_cup.runtime.Scanner s) {
		super(s);
	}

	/** Constructor which sets the default scanner. */
	public Parser(final java_cup.runtime.Scanner s, final java_cup.runtime.SymbolFactory sf) {
		super(s, sf);
	}

	/** Production table. */
	protected static final short _production_table[][] = unpackFromStrings(new String[] { "\000\032\000\002\002\004\000\002\002\003\000\002\003" + "\002\000\002\003\004\000\002\004\003\000\002\004\004" + "\000\002\004\005\000\002\004\003\000\002\004\005\000" + "\002\004\004\000\002\005\003\000\002\005\005\000\002" + "\006\002\000\002\006\003\000\002\007\003\000\002\007" + "\003\000\002\007\003\000\002\007\003\000\002\007\005" + "\000\002\007\005\000\002\007\005\000\002\007\005\000" + "\002\007\005\000\002\007\005\000\002\007\006\000\002" + "\007\003" });

	/** Access to production table. */
	@Override
	public short[][] production_table() {
		return _production_table;
	}

	/** Parse-action table. */
	protected static final short[][] _action_table = unpackFromStrings(new String[] { "\000\052\000\026\002\uffff\003\uffff\004\uffff\007\uffff\014" + "\uffff\120\uffff\121\uffff\122\uffff\123\uffff\124\uffff\001\002" + "\000\004\002\054\001\002\000\026\002\000\003\014\004" + "\012\007\011\014\015\120\006\121\020\122\007\123\016" + "\124\017\001\002\000\024\006\ufff3\014\ufff3\020\ufff3\051" + "\ufff3\052\ufff3\053\ufff3\054\ufff3\055\ufff3\077\ufff3\001\002" + "\000\024\006\ufff1\014\ufff1\020\ufff1\051\ufff1\052\ufff1\053" + "\ufff1\054\ufff1\055\ufff1\077\ufff1\001\002\000\020\014\053" + "\051\027\052\030\053\032\054\031\055\025\077\033\001" + "\002\000\026\003\uffff\004\uffff\007\uffff\010\uffff\014\uffff" + "\120\uffff\121\uffff\122\uffff\123\uffff\124\uffff\001\002\000" + "\030\002\ufffa\003\ufffa\004\ufffa\007\ufffa\010\ufffa\014\ufffa" + "\120\ufffa\121\ufffa\122\ufffa\123\ufffa\124\ufffa\001\002\000" + "\030\002\ufffe\003\ufffe\004\ufffe\007\ufffe\010\ufffe\014\ufffe" + "\120\ufffe\121\ufffe\122\ufffe\123\ufffe\124\ufffe\001\002\000" + "\020\014\050\051\uffe8\052\uffe8\053\uffe8\054\uffe8\055\uffe8" + "\077\uffe8\001\002\000\030\002\ufffd\003\ufffd\004\ufffd\007" + "\ufffd\010\ufffd\014\ufffd\120\ufffd\121\ufffd\122\ufffd\123\ufffd" + "\124\ufffd\001\002\000\020\003\021\005\023\120\006\121" + "\020\122\007\123\022\124\017\001\002\000\024\006\ufff0" + "\014\ufff0\020\ufff0\051\ufff0\052\ufff0\053\ufff0\054\ufff0\055" + "\ufff0\077\ufff0\001\002\000\024\006\ufff2\014\ufff2\020\ufff2" + "\051\ufff2\052\ufff2\053\ufff2\054\ufff2\055\ufff2\077\ufff2\001" + "\002\000\024\006\uffe8\014\uffe8\020\uffe8\051\uffe8\052\uffe8" + "\053\uffe8\054\uffe8\055\uffe8\077\uffe8\001\002\000\004\005" + "\023\001\002\000\020\003\021\006\ufff5\120\006\121\020" + "\122\007\123\022\124\017\001\002\000\020\014\026\051" + "\027\052\030\053\032\054\031\055\025\077\033\001\002" + "\000\016\003\021\120\006\121\020\122\007\123\022\124" + "\017\001\002\000\030\002\ufffb\003\ufffb\004\ufffb\007\ufffb" + "\010\ufffb\014\ufffb\120\ufffb\121\ufffb\122\ufffb\123\ufffb\124" + "\ufffb\001\002\000\016\003\021\120\006\121\020\122\007" + "\123\022\124\017\001\002\000\016\003\021\120\006\121" + "\020\122\007\123\022\124\017\001\002\000\016\003\021" + "\120\006\121\020\122\007\123\022\124\017\001\002\000" + "\016\003\021\120\006\121\020\122\007\123\022\124\017" + "\001\002\000\016\003\021\120\006\121\020\122\007\123" + "\022\124\017\001\002\000\024\006\uffea\014\uffea\020\uffea" + "\051\uffea\052\uffea\053\uffea\054\uffea\055\uffea\077\033\001" + "\002\000\024\006\uffed\014\uffed\020\uffed\051\uffed\052\uffed" + "\053\uffed\054\uffed\055\uffed\077\033\001\002\000\024\006" + "\uffec\014\uffec\020\uffec\051\uffec\052\uffec\053\uffec\054\uffec" + "\055\uffec\077\033\001\002\000\024\006\uffee\014\uffee\020" + "\uffee\051\uffee\052\uffee\053\032\054\031\055\025\077\033" + "\001\002\000\024\006\uffef\014\uffef\020\uffef\051\uffef\052" + "\uffef\053\032\054\031\055\025\077\033\001\002\000\024" + "\006\uffeb\014\uffeb\020\uffeb\051\uffeb\052\uffeb\053\uffeb\054" + "\uffeb\055\uffeb\077\033\001\002\000\006\006\ufff4\020\046" + "\001\002\000\004\006\045\001\002\000\022\006\ufff7\020" + "\ufff7\051\027\052\030\053\032\054\031\055\025\077\033" + "\001\002\000\024\006\uffe9\014\uffe9\020\uffe9\051\uffe9\052" + "\uffe9\053\uffe9\054\uffe9\055\uffe9\077\uffe9\001\002\000\016" + "\003\021\120\006\121\020\122\007\123\022\124\017\001" + "\002\000\022\006\ufff6\020\ufff6\051\027\052\030\053\032" + "\054\031\055\025\077\033\001\002\000\030\002\ufff8\003" + "\ufff8\004\ufff8\007\ufff8\010\ufff8\014\ufff8\120\ufff8\121\ufff8" + "\122\ufff8\123\ufff8\124\ufff8\001\002\000\026\003\014\004" + "\012\007\011\010\052\014\015\120\006\121\020\122\007" + "\123\016\124\017\001\002\000\030\002\ufff9\003\ufff9\004" + "\ufff9\007\ufff9\010\ufff9\014\ufff9\120\ufff9\121\ufff9\122\ufff9" + "\123\ufff9\124\ufff9\001\002\000\030\002\ufffc\003\ufffc\004" + "\ufffc\007\ufffc\010\ufffc\014\ufffc\120\ufffc\121\ufffc\122\ufffc" + "\123\ufffc\124\ufffc\001\002\000\004\002\001\001\002" });

	/** Access to parse-action table. */
	@Override
	public short[][] action_table() {
		return _action_table;
	}

	/** <code>reduce_goto</code> table. */
	protected static final short[][] _reduce_table = unpackFromStrings(new String[] { "\000\052\000\006\002\003\003\004\001\001\000\002\001" + "\001\000\006\004\012\007\007\001\001\000\002\001\001" + "\000\002\001\001\000\002\001\001\000\004\003\050\001" + "\001\000\002\001\001\000\002\001\001\000\002\001\001" + "\000\002\001\001\000\004\007\023\001\001\000\002\001" + "\001\000\002\001\001\000\002\001\001\000\002\001\001" + "\000\010\005\041\006\042\007\043\001\001\000\002\001" + "\001\000\004\007\040\001\001\000\002\001\001\000\004" + "\007\037\001\001\000\004\007\036\001\001\000\004\007" + "\035\001\001\000\004\007\034\001\001\000\004\007\033" + "\001\001\000\002\001\001\000\002\001\001\000\002\001" + "\001\000\002\001\001\000\002\001\001\000\002\001\001" + "\000\002\001\001\000\002\001\001\000\002\001\001\000" + "\002\001\001\000\004\007\046\001\001\000\002\001\001" + "\000\002\001\001\000\006\004\012\007\007\001\001\000" + "\002\001\001\000\002\001\001\000\002\001\001" });

	/** Access to <code>reduce_goto</code> table. */
	@Override
	public short[][] reduce_table() {
		return _reduce_table;
	}

	/** Instance of action encapsulation class. */
	protected CUP$Parser$actions action_obj;

	/** Action encapsulation object initializer. */
	@Override
	protected void init_actions() {
		action_obj = new CUP$Parser$actions(this);
	}

	/** Invoke a user supplied parse action. */
	@Override
	public java_cup.runtime.Symbol do_action(final int act_num, final java_cup.runtime.lr_parser parser, final java.util.Stack stack, final int top) throws java.lang.Exception {
		/* call code in generated class */
		return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
	}

	/** Indicates start state. */
	@Override
	public int start_state() {
		return 0;
	}

	/** Indicates start production. */
	@Override
	public int start_production() {
		return 0;
	}

	/** <code>EOF</code> Symbol index. */
	@Override
	public int EOF_sym() {
		return 0;
	}

	/** <code>error</code> Symbol index. */
	@Override
	public int error_sym() {
		return 1;
	}

	/** User initialization code. */
	@Override
	public void user_init() throws java.lang.Exception {

	}

	/** Scan to get the next Symbol. */
	@Override
	public java_cup.runtime.Symbol scan() throws java.lang.Exception {

		return getScanner().next_token();

	}

	/* (non-Javadoc)
	 * @see java_cup.runtime.lr_parser#syntax_error(java_cup.runtime.Symbol)
	 */
	@Override
	public void syntax_error(final Symbol token) {
		if (token instanceof ComplexSymbol) {

			final ComplexSymbol complexSymbol = (ComplexSymbol)token;
			final int line = complexSymbol.getLeft().getLine();
			final int column = complexSymbol.getLeft().getColumn();
			System.err.println("Syntax error at line " + line + ", col " + column + ", symbol " + complexSymbol.sym + ", value " + complexSymbol.value);

			System.err.print("Valid symbols at this point:");
			final int state = ((Symbol)stack.peek()).parse_state;
			final short[] actionRow = action_tab[state];
			for (int i = 0; i < actionRow.length; i += 2) {
				if (actionRow[i + 1] != 0) {
					System.err.print(" " + actionRow[i]);
				}
			}
			System.err.println();

		} else {
			super.syntax_error(token);
		}
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings("all")
class CUP$Parser$actions {
	private final Parser parser;

	/** Constructor */
	CUP$Parser$actions(final Parser parser) {
		this.parser = parser;
	}

	/** Method 0 with the actual generated action code for actions 0 to 300. */
	public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(final int CUP$Parser$act_num, final java_cup.runtime.lr_parser CUP$Parser$parser, final java.util.Stack CUP$Parser$stack, final int CUP$Parser$top) throws java.lang.Exception {
		/* Symbol object for return from actions */
		java_cup.runtime.Symbol CUP$Parser$result;

		/* select the action based on the action number */
		switch (CUP$Parser$act_num) {
		/*. . . . . . . . . . . . . . . . . . . .*/
		case 0: // $START ::= program EOF 
		{
			Object RESULT = null;
			final Location start_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).xleft;
			final Location start_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).xright;
			final StatementSequence start_val = (StatementSequence)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).value;
			RESULT = start_val;
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START", 0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			/* ACCEPT */
			CUP$Parser$parser.done_parsing();
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 1: // program ::= statements 
		{
			StatementSequence RESULT = null;
			final Location stsxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location stsxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final List<Statement> sts = (List<Statement>)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = new StatementSequence(sts);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("program", 0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 2: // statements ::= 
		{
			List<Statement> RESULT = null;
			RESULT = new ArrayList<Statement>();
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("statements", 1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 3: // statements ::= statements statement 
		{
			List<Statement> RESULT = null;
			final Location stsxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).xleft;
			final Location stsxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).xright;
			final List<Statement> sts = (List<Statement>)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).value;
			final Location stxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location stxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final Statement st = (Statement)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			sts.add(st);
			RESULT = sts;
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("statements", 1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 4: // statement ::= SEMICOLON 
		{
			Statement RESULT = null;
			RESULT = new NopStatement();
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement", 2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 5: // statement ::= expression SEMICOLON 
		{
			Statement RESULT = null;
			final Location exleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).xleft;
			final Location exright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).xright;
			final Expression e = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).value;
			RESULT = new ExpressionStatement(e);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement", 2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 6: // statement ::= IDENTIFIER expression SEMICOLON 
		{
			Statement RESULT = null;
			final Location idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xleft;
			final Location idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xright;
			final String id = (String)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).value;
			final Location exleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).xleft;
			final Location exright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).xright;
			final Expression e = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).value;
			RESULT = new ExpressionStatement(new FunctionCall(id, e));
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement", 2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 7: // statement ::= VERBATIM_CONTENT 
		{
			Statement RESULT = null;
			final Location cxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location cxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final String c = (String)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = new ExpressionStatement(new FunctionCall("echo", new LiteralExpression(c)));
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement", 2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 8: // statement ::= OPENING_CURLY_BRACE statements CLOSING_CURLY_BRACE 
		{
			Statement RESULT = null;
			final Location stsxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).xleft;
			final Location stsxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).xright;
			final List<Statement> sts = (List<Statement>)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).value;
			RESULT = new StatementSequence(sts);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement", 2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 9: // statement ::= error SEMICOLON 
		{
			Statement RESULT = null;
			System.err.println("syntax error");
			RESULT = new NopStatement();
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement", 2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 10: // one_or_more_expressions ::= expression 
		{
			List<Expression> RESULT = null;
			final Location exxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location exxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final Expression ex = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = new ArrayList<Expression>();
			RESULT.add(ex);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("one_or_more_expressions", 3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 11: // one_or_more_expressions ::= one_or_more_expressions COMMA expression 
		{
			List<Expression> RESULT = null;
			final Location exsxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xleft;
			final Location exsxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xright;
			final List<Expression> exs = (List<Expression>)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).value;
			final Location exxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location exxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final Expression ex = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			exs.add(ex);
			RESULT = exs;
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("one_or_more_expressions", 3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 12: // expressions ::= 
		{
			List<Expression> RESULT = null;
			RESULT = new ArrayList<Expression>();
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expressions", 4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 13: // expressions ::= one_or_more_expressions 
		{
			List<Expression> RESULT = null;
			final Location exsxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location exsxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final List<Expression> exs = (List<Expression>)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = exs;
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expressions", 4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 14: // expression ::= BOOLEAN_LITERAL 
		{
			Expression RESULT = null;
			final Location exleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location exright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final Boolean e = (Boolean)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = new LiteralExpression(e);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression", 5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 15: // expression ::= INTEGER_LITERAL 
		{
			Expression RESULT = null;
			final Location exleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location exright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final Integer e = (Integer)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = new LiteralExpression(e);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression", 5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 16: // expression ::= STRING_LITERAL 
		{
			Expression RESULT = null;
			final Location exleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location exright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final String e = (String)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = new LiteralExpression(e);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression", 5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 17: // expression ::= LOCAL_VARIABLE 
		{
			Expression RESULT = null;
			final Location exleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location exright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final String e = (String)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = new LocalVariableExpression(e);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression", 5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 18: // expression ::= expression PLUS expression 
		{
			Expression RESULT = null;
			final Location e1xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xleft;
			final Location e1xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xright;
			final Expression e1 = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).value;
			final Location e2xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location e2xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final Expression e2 = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = new BinaryExpression(e1, BinaryOperator.ADD, e2);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression", 5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 19: // expression ::= expression MINUS expression 
		{
			Expression RESULT = null;
			final Location e1xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xleft;
			final Location e1xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xright;
			final Expression e1 = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).value;
			final Location e2xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location e2xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final Expression e2 = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = new BinaryExpression(e1, BinaryOperator.SUBTRACT, e2);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression", 5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 20: // expression ::= expression TIMES expression 
		{
			Expression RESULT = null;
			final Location e1xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xleft;
			final Location e1xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xright;
			final Expression e1 = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).value;
			final Location e2xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location e2xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final Expression e2 = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = new BinaryExpression(e1, BinaryOperator.MULTIPLY, e2);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression", 5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 21: // expression ::= expression DIVIDE expression 
		{
			Expression RESULT = null;
			final Location e1xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xleft;
			final Location e1xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xright;
			final Expression e1 = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).value;
			final Location e2xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location e2xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final Expression e2 = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = new BinaryExpression(e1, BinaryOperator.DIVIDE, e2);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression", 5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 22: // expression ::= expression MOD expression 
		{
			Expression RESULT = null;
			final Location e1xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xleft;
			final Location e1xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xright;
			final Expression e1 = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).value;
			final Location e2xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location e2xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final Expression e2 = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = new BinaryExpression(e1, BinaryOperator.REMAINDER, e2);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression", 5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 23: // expression ::= expression ASSIGN expression 
		{
			Expression RESULT = null;
			final Location e1xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xleft;
			final Location e1xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).xright;
			final Expression e1 = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)).value;
			final Location e2xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
			final Location e2xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
			final Expression e2 = (Expression)((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).value;
			RESULT = new BinaryExpression(e1, BinaryOperator.ASSIGN, e2);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression", 5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 24: // expression ::= IDENTIFIER OPENING_PARENTHESIS expressions CLOSING_PARENTHESIS 
		{
			Expression RESULT = null;
			final Location idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 3)).xleft;
			final Location idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 3)).xright;
			final String id = (String)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 3)).value;
			final Location exsxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).xleft;
			final Location exsxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).xright;
			final List<Expression> exs = (List<Expression>)((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 1)).value;
			RESULT = new FunctionCall(id, exs.toArray(new Expression[exs.size()]));
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression", 5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top - 3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/*. . . . . . . . . . . . . . . . . . . .*/
		case 25: // expression ::= error 
		{
			Expression RESULT = null;
			RESULT = new LiteralExpression(null);
			CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression", 5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
		}
			return CUP$Parser$result;

			/* . . . . . .*/
		default:
			throw new Exception("Invalid action number " + CUP$Parser$act_num + "found in internal parse table");

		}
	} /* end of method */

	/** Method splitting the generated action code into several parts. */
	public final java_cup.runtime.Symbol CUP$Parser$do_action(final int CUP$Parser$act_num, final java_cup.runtime.lr_parser CUP$Parser$parser, final java.util.Stack CUP$Parser$stack, final int CUP$Parser$top) throws java.lang.Exception {
		return CUP$Parser$do_action_part00000000(CUP$Parser$act_num, CUP$Parser$parser, CUP$Parser$stack, CUP$Parser$top);
	}
}
