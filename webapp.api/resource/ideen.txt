Another interesting and light-weight option would be to have Java generate PHP code and then use PHP include()
directive to fetch that over HTTP and execute it. I haven't tried this though.
->
When Java generates you're PHP code, the resulting PHP code will be different each time it run's.
Thus depending how PHP opcode caching exactly works, this solution has a high change of disables
PHP caching (APC, eAccelerator, etc) and thus degrading performance for all scripts that include
this java generated PHP code.

---

Ein erster Schritt ist, das iPhone-Backend aufzuräumen. Unit-Tests werden leider
wegen der sich ändernden Datenbank nicht gut gehen, also nur manuelle Tests.
Dieser Schritt ist in jedem Fall sinnvoll, selbst wenn alles bei dem alten
PHP Kram bleibt.

Nächster Schritt ist, eine "saubere" Version der App-Api zu bauen, also
aufräumen MIT nach außen sichtbaren Änderungen. Dazu evtl. eine zweite
Komponente neben der IphoneAppComponent: CommonAppComponent, die von
ersterer und der aufgeräumten Api benutzt wird und sauber und flexibel
ist, dafür evtl. komplizierter zu benutzen. Die verschiedenen API-Komponenten
mappen dann darauf. Die neue API ist auch flexibel, allerdings sind
nach außen sichtbare Funktionen ggf. in der Komplexität eingeschränkt
im Vergleich zur CommonAppComponent (z.B. weil keine komplexen Parameter
angegeben werden können).

Danach können die einzelnen Stücke in Java nachgebaut werden. Parallel dazu
kann es jetzt eine Wicket-WebApp geben, die die flexiblere neue API
benutzt. Die iPhone-API ist evtl. zu eingeschränkt dafür (könnte gehen,
ist aber nicht sicher).

---

Ansatz: In den von QueryDSL generierten Klassen auch gleich die Caches mit generieren.
Das kann z.B. anhand einer einfachen Konfig-Datei gehen (Java Properties). Annotations
leider nicht, weil keine Klasse da ist, wo man A. dranschreiben könnte.

Außerdem: Generierte statische Methoden in den generierten Klassen, die auf
vorhandene statische Methoden in einer manuell geschriebenen Klasse delegieren.

-----

Multi-key-cache:

- Klasse AlternativeCacheKeyGroup(Cache) implements removal listener
- Methode createAlternativeKeyCache (manually managed; hält sich über den
  removal listener aktuell).

1. Group erzeugen
2. Loader erzeugen
3. Main Cache erzeugen
4. Alternative caches erzeugen

Removal schön und gut, aber wie funktioniert das jetzt konkret?

-----

Ein zentraler Cache mit Maps außenrum -> Race Conditions ahoi!

Anderer Ansatz: N Caches, die sich gegenseitig Update-Notifications zusenden. Dabei sind
die Removal Notifications fast egal, wenn man davon ausgeht, dass auch der N-fache
Speicher gebraucht wird (bei sharing weniger), wobei auch Removal eine Notification
auslösen kann. Die Caches selbst brauchen eh nicht so viel Speicher, große Values sind
viel kritischer.

Also Idee: Jedesmal, wenn ein Cache einen Wert einlagert, wird dieser auf alle Key-Types
gemappt und an alle Caches gesendet. Das ist in diesem Sinne weniger eine Framework-
Funktionalität als ein Design Pattern.






