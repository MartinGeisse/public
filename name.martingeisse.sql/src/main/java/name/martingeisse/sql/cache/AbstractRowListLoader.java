/**
 * Copyright (c) 2011 Martin Geisse
 *
 * This file is distributed under the terms of the MIT license.
 */

package name.martingeisse.sql.cache;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import name.martingeisse.common.util.ParameterUtil;
import name.martingeisse.common.util.ReturnValueUtil;
import com.google.common.base.Equivalence.Wrapper;
import com.google.common.cache.CacheLoader;
import com.mysema.commons.lang.CloseableIterator;
import com.mysema.query.sql.RelationalPath;
import com.mysema.query.sql.SQLQuery;
import com.mysema.query.types.Expression;
import com.mysema.query.types.OrderSpecifier;
import com.mysema.query.types.Predicate;

/**
 * Cache loader implementation for a multi-row, transformed cache.
 * That is, each cache value is generated by the subclass from a list
 * of rows fetched for the same cache key. The value may be or contain a
 * list of values, each generated from a single row, but the cached value
 * may also contain global values generated from all rows for the same
 * cache key.
 * 
 * As per the {@link CacheLoader} specification, the transformation method
 * must not return null. Use {@link Wrapper} if null values must be cached.
 * 
 * @param <K> the type of cache keys
 * @param <R> the table row bean type
 * @param <V> the type of cached values
 */
public abstract class AbstractRowListLoader<K, R, V> extends AbstractDatabaseCacheLoader<K, V> {

	/**
	 * the path
	 */
	private final RelationalPath<R> path;
	
	/**
	 * the keyExpression
	 */
	private final Expression<?> keyExpression;
	
	/**
	 * the orderSpecifiers
	 */
	private final OrderSpecifier<?>[] orderSpecifiers;
	
	/**
	 * the additionalPredicates
	 */
	private final Predicate[] additionalPredicates;
	
	/**
	 * Constructor.
	 * @param path the table path
	 * @param keyExpression the key expression
	 * @param additionalPredicates additional predicates (if any)
	 */
	public AbstractRowListLoader(RelationalPath<R> path, Expression<?> keyExpression, Predicate... additionalPredicates) {
		this(path, keyExpression, new OrderSpecifier<?>[0], additionalPredicates);
	}
	
	/**
	 * Constructor.
	 * @param path the table path
	 * @param keyExpression the key expression
	 * @param orderSpecifier the result order
	 * @param additionalPredicates additional predicates (if any)
	 */
	public AbstractRowListLoader(RelationalPath<R> path, Expression<?> keyExpression, OrderSpecifier<?> orderSpecifier, Predicate... additionalPredicates) {
		this(path, keyExpression, new OrderSpecifier<?>[] {orderSpecifier}, additionalPredicates);
	}
	
	/**
	 * Constructor.
	 * @param path the table path
	 * @param keyExpression the key expression
	 * @param orderSpecifiers the result order
	 * @param additionalPredicates additional predicates (if any)
	 */
	public AbstractRowListLoader(RelationalPath<R> path, Expression<?> keyExpression, OrderSpecifier<?>[] orderSpecifiers, Predicate... additionalPredicates) {
		this.path = ParameterUtil.ensureNotNull(path, "path");
		this.keyExpression = ParameterUtil.ensureNotNull(keyExpression, "keyExpression");
		this.orderSpecifiers = orderSpecifiers;
		this.additionalPredicates = ParameterUtil.ensureNotNull(additionalPredicates, "additionalPredicates");
	}

	/* (non-Javadoc)
	 * @see com.google.common.cache.CacheLoader#load(java.lang.Object)
	 */
	@Override
	public V load(K key) throws Exception {
		ParameterUtil.ensureNotNull(key, "key");
		SQLQuery query = ReturnValueUtil.nullNotAllowed(createQuery(), "createQuery()");
		query.from(path).where(createKeyEqualsPredicate(keyExpression, key));
		query.where(additionalPredicates).orderBy(orderSpecifiers);
		return transformValue(key, query.list(path));
	}
	
	/* (non-Javadoc)
	 * @see com.google.common.cache.CacheLoader#loadAll(java.lang.Iterable)
	 */
	@Override
	public Map<K, V> loadAll(Iterable<? extends K> keys) throws Exception {
		
		// build the query
		ParameterUtil.ensureNotNull(keys, "keys");
		ParameterUtil.ensureNoNullElement(keys, "keys");
		SQLQuery query = ReturnValueUtil.nullNotAllowed(createQuery(), "createQuery()");
		query.from(path).where(createKeyInPredicate(keyExpression, keys));
		query.where(additionalPredicates).orderBy(orderSpecifiers);
		
		// fetch results and store them in a map, indexed by value of the key expression
		Map<K, List<R>> foundValues = new HashMap<K, List<R>>();
		try (CloseableIterator<Object[]> iterator = query.iterate(keyExpression, path)) {
			while (iterator.hasNext()) {
				Object[] entry = iterator.next();
				@SuppressWarnings("unchecked") K key = (K)entry[0];
				@SuppressWarnings("unchecked") R row = (R)entry[1];
				List<R> rowList = foundValues.get(key);
				if (rowList == null) {
					rowList = new ArrayList<R>();
					foundValues.put(key, rowList);
				}
				rowList.add(row);
			}
		}

		// create the result list, using null for missing keys
		List<List<R>> preTransformationResult = new ArrayList<List<R>>();
		for (K key : keys) {
			List<R> foundList = foundValues.get(key);
			preTransformationResult.add(foundList == null ? new ArrayList<R>() : foundList);
		}
		
		// transform the result list
		return transformValues(keys, preTransformationResult);
		
	}

	/**
	 * Transforms a list of rows for a single key.
	 * 
	 * @param rows the row list to transform (empty if no row was found for that key; never null)
	 * @return the value (may be null to store a null value in the cache)
	 */
	protected abstract V transformValue(K key, List<R> rows);

	/**
	 * Transforms row lists for multiple keys at once. This method provides a default implementation that
	 * invokes {@link #transformValue(Serializable, List)} on each element. Subclasses are encouraged
	 * to provide a more efficient implementation where possible.
	 * 
	 * @param rowLists the row lists to transform. The list itself is never null, nor are its element
	 * lists null. Element lists may be empty whenever no row was found for a key. This method can
	 * assume that neither the argument list nor any of its element lists is used by the caller
	 * after this method is invoked, so the lists may, for example, be modified or re-used for the
	 * result list.
	 * @return the values. Must not be null. Must not contain null.
	 */
	protected Map<K, V> transformValues(Iterable<? extends K> keys, List<List<R>> rowLists) {
		Map<K, V> result = new HashMap<K, V>();
		Iterator<? extends K> keyIterator = keys.iterator();
		Iterator<List<R>> rowListIterator = rowLists.iterator();
		while (keyIterator.hasNext()) {
			K key = keyIterator.next();
			List<R> rows = rowListIterator.next();
			V value = transformValue(key, rows);
			result.put(key, value);
		}
		return result;
	}
	
}
