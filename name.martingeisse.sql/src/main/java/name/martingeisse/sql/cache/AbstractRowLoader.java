/**
 * Copyright (c) 2011 Martin Geisse
 *
 * This file is distributed under the terms of the MIT license.
 */

package name.martingeisse.sql.cache;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import name.martingeisse.common.util.ParameterUtil;
import name.martingeisse.common.util.ReturnValueUtil;
import com.google.common.base.Equivalence.Wrapper;
import com.google.common.cache.CacheLoader;
import com.mysema.commons.lang.CloseableIterator;
import com.mysema.query.sql.RelationalPath;
import com.mysema.query.sql.SQLQuery;
import com.mysema.query.types.Expression;
import com.mysema.query.types.Predicate;

/**
 * Cache loader implementation for a single-row, transformed cache.
 * That is, each cache value is generated by the subclass from a single row.
 * 
 * As per the {@link CacheLoader} specification, the transformation method
 * must not return null. Use {@link Wrapper} if null values must be cached.
 * 
 * @param <K> the type of cache keys
 * @param <R> the table row bean type
 * @param <V> the type of cached values
 */
public abstract class AbstractRowLoader<K, R, V> extends AbstractDatabaseCacheLoader<K, V> {

	/**
	 * the path
	 */
	private final RelationalPath<R> path;
	
	/**
	 * the keyExpression
	 */
	private final Expression<?> keyExpression;
	
	/**
	 * the additionalPredicates
	 */
	private final Predicate[] additionalPredicates;
	
	/**
	 * Constructor.
	 * @param path the table path
	 * @param keyExpression the key expression
	 * @param additionalPredicates additional predicates (if any)
	 */
	public AbstractRowLoader(RelationalPath<R> path, Expression<?> keyExpression, Predicate... additionalPredicates) {
		this.path = ParameterUtil.ensureNotNull(path, "path");
		this.keyExpression = ParameterUtil.ensureNotNull(keyExpression, "keyExpression");
		this.additionalPredicates = ParameterUtil.ensureNotNull(additionalPredicates, "additionalPredicates");
	}

	/* (non-Javadoc)
	 * @see com.google.common.cache.CacheLoader#load(java.lang.Object)
	 */
	@Override
	public V load(K key) throws Exception {
		ParameterUtil.ensureNotNull(key, "key");
		SQLQuery query = ReturnValueUtil.nullNotAllowed(createQuery(), "createQuery()");
		query.from(path).where(createKeyEqualsPredicate(keyExpression, key));
		query.where(additionalPredicates).limit(1);
		return transformValue(key, query.singleResult(path));
	}
	
	/* (non-Javadoc)
	 * @see com.google.common.cache.CacheLoader#loadAll(java.lang.Iterable)
	 */
	@SuppressWarnings("unchecked")
	@Override
	public Map<K, V> loadAll(Iterable<? extends K> keys) throws Exception {
		
		// build the query
		ParameterUtil.ensureNotNull(keys, "keys");
		ParameterUtil.ensureNoNullElement(keys, "keys");
		SQLQuery query = ReturnValueUtil.nullNotAllowed(createQuery(), "createQuery()");
		query.from(path).where(createKeyInPredicate(keyExpression, keys));
		query.where(additionalPredicates);
		
		// fetch results and store them in a map, indexed by value of the key expression
		Map<K, R> foundValues = new HashMap<K, R>();
		try (CloseableIterator<Object[]> iterator = query.iterate(keyExpression, path)) {
			while (iterator.hasNext()) {
				Object[] entry = iterator.next();
				foundValues.put((K)entry[0], (R)entry[1]);
			}
		}
		
		// create the result list, using null for missing keys
		List<R> preTransformationResult = new ArrayList<R>();
		for (K key : keys) {
			preTransformationResult.add(foundValues.get(key));
		}
		
		// transform the result list
		return transformValues(keys, preTransformationResult);
		
	}

	/**
	 * Transforms a single row.
	 * 
	 * @param row the row to transform (may be null if no row was found)
	 * @return the value (may be null to store a null value in the cache)
	 */
	protected abstract V transformValue(K key, R row);

	/**
	 * Transforms the rows for multiple cache keys at once. This method provides a default implementation
	 * that invokes {@link #transformValue(Serializable, Object)} on each element. Subclasses are encouraged
	 * to provide a more efficient implementation where possible.
	 * 
	 * @param rows the rows to transform. The list itself is never null, but may contain null elements
	 * whenever no row was found for a key. This method can assume that the argument list is not used
	 * by the caller after this method is invoked, so the list may, for example, be modified or
	 * re-used for the result list.
	 * @return the values. Must not be null. Must not contain null.
	 */
	protected Map<K, V> transformValues(Iterable<? extends K> keys, List<R> rows) {
		Map<K, V> result = new HashMap<K, V>();
		Iterator<? extends K> keyIterator = keys.iterator();
		Iterator<R> rowIterator = rows.iterator();
		while (keyIterator.hasNext()) {
			K key = keyIterator.next();
			R row = rowIterator.next();
			V value = transformValue(key, row);
			result.put(key, value);
		}
		return result;
	}
	
}
